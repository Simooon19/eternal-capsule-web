import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity';
import JSZip from 'jszip';

interface Params {
  id: string;
}

export async function GET(
  request: NextRequest,
  { params }: { params: Params }
) {
  try {
    // Fetch complete memorial data
    const memorial = await client.fetch(
      `*[_type == "memorial" && _id == $id][0] {
        ...,
        gallery[] {
          ...,
          asset-> {
            _id,
            url,
            originalFilename,
            metadata
          }
        },
        videos[] {
          ...,
          asset-> {
            _id,
            url,
            originalFilename,
            metadata
          }
        },
        audioMemories[] {
          ...,
          asset-> {
            _id,
            url,
            originalFilename,
            metadata
          }
        },
        guestbook[] {
          _id,
          author,
          message,
          createdAt,
          status
        }
      }`,
      { id: params.id }
    );

    if (!memorial) {
      return NextResponse.json(
        { error: 'Memorial not found' },
        { status: 404 }
      );
    }

    // Create ZIP file
    const zip = new JSZip();

    // Add memorial data as JSON
    const memorialData = {
      ...memorial,
      exportedAt: new Date().toISOString(),
      exportVersion: '1.0'
    };
    
    zip.file('memorial-data.json', JSON.stringify(memorialData, null, 2));

    // Add photos
    if (memorial.gallery && memorial.gallery.length > 0) {
      const photosFolder = zip.folder('photos');
      
      for (let i = 0; i < memorial.gallery.length; i++) {
        const image = memorial.gallery[i];
        if (image.asset?.url) {
          try {
            const response = await fetch(image.asset.url);
            const blob = await response.blob();
            const arrayBuffer = await blob.arrayBuffer();
            
            const filename = image.asset.originalFilename || `photo-${i + 1}.jpg`;
            photosFolder?.file(filename, arrayBuffer);
          } catch (error) {
            console.error(`Failed to download photo ${i + 1}:`, error);
          }
        }
      }
    }

    // Add videos
    if (memorial.videos && memorial.videos.length > 0) {
      const videosFolder = zip.folder('videos');
      
      for (let i = 0; i < memorial.videos.length; i++) {
        const video = memorial.videos[i];
        if (video.asset?.url) {
          try {
            const response = await fetch(video.asset.url);
            const blob = await response.blob();
            const arrayBuffer = await blob.arrayBuffer();
            
            const filename = video.asset.originalFilename || `video-${i + 1}.mp4`;
            videosFolder?.file(filename, arrayBuffer);
          } catch (error) {
            console.error(`Failed to download video ${i + 1}:`, error);
          }
        }
      }
    }

    // Add audio files
    if (memorial.audioMemories && memorial.audioMemories.length > 0) {
      const audioFolder = zip.folder('audio');
      
      for (let i = 0; i < memorial.audioMemories.length; i++) {
        const audio = memorial.audioMemories[i];
        if (audio.asset?.url) {
          try {
            const response = await fetch(audio.asset.url);
            const blob = await response.blob();
            const arrayBuffer = await blob.arrayBuffer();
            
            const filename = audio.asset.originalFilename || `audio-${i + 1}.mp3`;
            audioFolder?.file(filename, arrayBuffer);
          } catch (error) {
            console.error(`Failed to download audio ${i + 1}:`, error);
          }
        }
      }
    }

    // Add guestbook as CSV
    if (memorial.guestbook && memorial.guestbook.length > 0) {
      const csvHeader = 'Author,Message,Date,Status\n';
      const csvRows = memorial.guestbook.map((entry: any) => 
        `"${entry.author}","${entry.message.replace(/"/g, '""')}","${entry.createdAt}","${entry.status}"`
      ).join('\n');
      
      zip.file('guestbook.csv', csvHeader + csvRows);
    }

    // Add README file
    const readme = `# Memorial Export: ${memorial.title}

This archive contains all data from the memorial for ${memorial.title}.

## Contents:
- memorial-data.json: Complete memorial data in JSON format
- photos/: All uploaded photos
- videos/: All uploaded videos (if any)
- audio/: All uploaded audio memories (if any)
- guestbook.csv: All guestbook entries in CSV format

## Export Information:
- Exported on: ${new Date().toISOString()}
- Export version: 1.0
- Memorial ID: ${memorial._id}

This export was generated by Eternal Capsule Memorial System.
`;

    zip.file('README.md', readme);

    // Generate ZIP file
    const zipBuffer = await zip.generateAsync({ type: 'arraybuffer' });

    // Return ZIP file as download
    const response = new NextResponse(zipBuffer);
    response.headers.set('Content-Type', 'application/zip');
    response.headers.set(
      'Content-Disposition', 
      `attachment; filename="memorial-${memorial.slug.current}-${new Date().toISOString().split('T')[0]}.zip"`
    );

    return response;
  } catch (error) {
    console.error('Error exporting memorial:', error);
    return NextResponse.json(
      { error: 'Failed to export memorial' },
      { status: 500 }
    );
  }
}